---
title: "r4lineups: Statistical Inference on Lineup Fairness"
author: "Colin Tredoux"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{r4lineups: Statistical Inference on Lineup Fairness}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = NA
)
```

This package contains functions to compute various estimates of lineup fairness, allowing eyewitness testimony researchers to reason inferentially about several well-known measures of lineup fairness developed in psychological research. 

The measures described below were developed by _______ (see References). Several other functions contained in this package are variations of measures of lineup fairness adapted from (refs), and modified by Professor Colin Tredoux. 


## Data Format

The majority of r4lineups functions require a vector of numeric lineup data, whilst other functions require the user to pass a list of lineup data. It is advisable to read the documentation to determine the format of data needed by each specific function. Most r4lineups functions will not work with a dataframe, even if the dataframe contains only one vector. If your lineup data is in dataframe format already, you can easily convert it to a vector or a list. 

```{r,}
library(r4lineups)
data("CGTmock")
```

```{r, echo=FALSE, results='asis'}
pander::pandoc.table(CGTmock[1:3,], "CTGmock Dataframe")
```

* For functions that require data for only one lineup or one lineup pair, you can convert the data from a given lineup to a vector by calling `lineup_vec <- CGTmock$lineup_1`

* For functions that require several lineups or several lineup pairs, you can convert the data to a list by calling `lineup_list <- as.list(CGTmock)`
    
```{r, include=FALSE}
lineup_vec <- CGTmock$lineup_1
lineup_list <- as.list(CGTmock)
```

### Nominal Size

Functions which rely on nominal size for accurate calculations will require the user to manually specify nominal size. If nominal size, as specified by the user, is not reflected in the data passed to the function, execution of the function is halted with the following error message: 

-----

## Lineup Proportion

Proportion refers to the proportion of witnesses selecting a particular member of a lineup. This package provides calculations of proportion for individual lineup members, and for all members of a lineup. 

### Calculating proportion for a single target/lineup member:
```{r}
library(r4lineups)

lineup_prop_vec(lineup_vec, 3)
```
The function returns a proportion indicating the frequency with which the target/linuep member occupying position 3 in the lineup was identified by 14.29% of the witnesses, or 14.29% of the time. 

__Bootstrapped estimates__

To calculate boostrapped lineup proportion for a single lineup member, we pass the `lineup_prop_boot` function as an argument to the `boot` function supplied by the package 'boot':

```{r, warning=FALSE}
bootobject <- boot::boot(lineup_vec, lineup_prop_boot, target_pos = 3, R = 1000)
bootobject
```

Then we compute confidence intervals:

```{r, warning=FALSE}
cis <- boot::boot.ci(bootobject, conf = 0.95, type = "all")
cis
```

### Calculating proportion for each lineup member

Should the user want to calculate proportion for each member of a given lineup, the `allprop` function can be called. Instead of the user specifying the target position, a vector indexing all target positions is passed to the function. This can be manually generated by calling `target_pos <- c(1:k)`

```{r, echo=FALSE  }
target_pos <- c(1:8)
```
```{r}
allprop(lineup_vec, target_pos, 8)
```


__Bootstrapped estimates__

```{r}
lineuprops.ci <- lineup_boot_allprop(lineup_vec, target_pos, k=8)
lineuprops.ci
```

_Note_: k refers to nominal size, and must be explicitly declared by the user (see Data Format section, above)

---
## Functional Size

To compute functional size with confidence intervals, we call func_size_report, and pass a vector of lineup data and a scalar indicating target position:

```{r}
func_size_report(lineup_vec, 3)
```

---

## Effective Size

This package allows the user to calculate effective size in several different ways. 

1. Malpass (1981) & Tredoux (1998)

    Effective size can be computed by calling the `esize_m` function and passing a    vector of lineup data. If printarg = FALSE, only Tredoux's adjusted effective size estimate is returned. If printarg = TRUE, both Tredoux's and Malpass's calculations of effective size are returned. 

```{r}
esize_m(lineup_vec, printarg = TRUE)
```
    
* __Get bootstrapped estimates:__

```{r, indent = "  "}
#Create a dataframe of bootstrapped lineup data
bootdata <- gen_boot_samples(lineup_vec, 1000)

#Calculate effective size for each lineup in bootdata
lineupsizes <- gen_esize_m(bootdata)

#Calculate lower and upper CIs with desired level of alpha
gen_esize_m_ci(lineupsizes, perc = .025)
gen_esize_m_ci(lineupsizes, perc = .975)
```


2. Effective Size Per Foils

    To calculate effective size by counting the number of foils who fall within the CI for chance guessing, we pass a vector of lineup data, a vector of target positions and nominal size. 
```{r}
eff_size_per_foils(lineup_vec, target_pos, 8)
```

### Comparing two effective sizes

To test if the effective size of 2 independent lineups are significantly different from one another, we take the difference between said effective sizes and calculate CIs.

This function requires a dataframe containing lineup data for 2 independent lineups

```{r}
data("CGTmock")
linedf <- CGTmock[1:2]

effsize_compare(linedf)
```

