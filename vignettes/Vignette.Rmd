---
title: "r4lineups"
subtitle: "Statistical Inference on Measures of Lineup Fairness"
author: 
- "Colin G. Tredoux"
- "Tamsyn M. Naylor"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{r4lineups: Statistical Inference on Lineup Fairness}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = NA
)
```

This package contains functions to compute various estimates of lineup fairness, allowing eyewitness testimony researchers to reason inferentially about several well-known measures of lineup fairness developed in psychological research. 

The measures described below were developed by _______ (see References). Several other functions contained in this package are variations of measures of lineup fairness adapted from (refs), and modified by Professor Colin Tredoux. 


## Data Format

The majority of r4lineups functions require a vector of numeric lineup data, whilst other functions require the user to pass a list of lineup data. It is advisable to read the documentation to determine the format of data needed by each specific function. Most r4lineups functions will not work with a dataframe, even if the dataframe contains only one vector. If your lineup data is in dataframe format already, you can easily convert it to a vector or a list. 

```{r,}
library(r4lineups)
data("CGTmock")
```

```{r, echo=FALSE, results='asis'}
pander::pandoc.table(CGTmock[1:3,], "CTGmock data")
```

* For functions that require data for only one lineup or one lineup pair, you can convert the data from a given lineup to a vector by calling `lineup_vec <- CGTmock$lineup_1`

* For functions that require several lineups or several lineup pairs, you can convert the data to a list by calling `lineup_list <- as.list(CGTmock)`
    
```{r, include=FALSE}
lineup_vec <- CGTmock$lineup_1
lineup_list <- as.list(CGTmock)
```

* __Nominal Size__

    Functions relying on nominal size for accurate calculations require the user to manually specify nominal size. If nominal size, as specified by the user, is not reflected in the dataframe or vector passed to the function, execution of the function is halted with the following error message: 

-----

## Lineup Proportion

Proportion refers to the proportion of witnesses selecting a particular member of a lineup. This package provides calculations of proportion for individual lineup members, and for all members of a lineup. 

### Calculating proportion for a single target/lineup member:
```{r}
library(r4lineups)

lineup_prop_vec(lineup_vec, 3)
```
The function returns a proportion indicating the frequency with which the target/linuep member occupying position 3 in the lineup was identified by 14.29% of the witnesses, or 14.29% of the time. 

* _Compute bootstrapped estimates:_

    To calculate boostrapped lineup proportion for a single lineup member, we pass the `lineup_prop_boot` function as an argument to the `boot` function supplied by the package 'boot':

```{r, indent = "  ", warning=FALSE,}
bootobject <- boot::boot(lineup_vec, lineup_prop_boot, target_pos = 3, R = 1000)
bootobject
```

    + _We then compute confidence intervals:_

```{r, warning=FALSE, indent = "  "}
cis <- boot::boot.ci(bootobject, conf = 0.95, type = "all")
cis
```

### Calculating proportion for each lineup member

Should the user want to calculate proportion for each member of a given lineup, the `allprop` function can be called. Instead of the user specifying the target position, a vector indexing all target positions is passed to the function. This can be manually generated by calling `target_pos <- c(1:k)`.

```{r, echo=FALSE  }
target_pos <- c(1:8)
```
```{r}
allprop(lineup_vec, target_pos, 8)
```


* _Compute bootstrapped estimates:_

```{r, indent = "  "}
lineuprops.ci <- lineup_boot_allprop(lineup_vec, target_pos, k=8)
lineuprops.ci
```

&nbsp; _Note_: _k_ = nominal size, and must be explicitly declared by the user (for more info, see the __Data Format__ section, above).

---

## Functional Size

* To compute functional size with confidence intervals, we call `func_size_report`, and pass a vector of lineup data and a scalar indicating target position:

```{r, indent = "  "}
func_size_report(lineup_vec, 3)
```

   The functional size of the lineup is 3. 
   
---

## Effective Size

This package allows the user to calculate effective size in several different ways. 

1. __Malpass (1981) & Tredoux (1998)__

    Effective size can be computed by calling the `esize_m` function and passing a    vector of lineup data. If printarg = FALSE, only Malpass's formula for effective size is used. If printarg = TRUE, both Tredoux's and Malpass's calculations of effective size are returned. 

```{r}
esize_m(lineup_vec, printarg = TRUE)
```
    
* _Compute bootstrapped estimates:_

```{r,indent = "  "}
#Create a dataframe of bootstrapped lineup data
bootdata <- gen_boot_samples(lineup_vec, 1000)

#Calculate effective size for each lineup in bootdata
lineupsizes <- gen_esize_m(bootdata)

#Calculate lower and upper CIs with desired level of alpha
gen_esize_m_ci(lineupsizes, perc = .025)
gen_esize_m_ci(lineupsizes, perc = .975)
```


2. __Effective Size Per Foils__

    To calculate effective size by counting the number of foils who fall within the CI for chance guessing, we pass a vector of lineup data, a vector of target positions and nominal size. 
```{r}
eff_size_per_foils(lineup_vec, target_pos, 8)
```

### Comparing two effective sizes

To test if the effective size of 2 independent lineups are significantly different from one another, we take the difference between said effective sizes and calculate CIs. This function requires a dataframe containing lineup data for 2 independent lineups. Here, we create a new dataframe containing 2 independent lineups from `CGTmock`.

```{r}
#Get data
linedf <- CGTmock[1:2]
#Compare effective size
effsize_compare(linedf)
```
The effective size for lineup_1 is therefore not significantly different from the effective size for lineup_2.

---

## Diagnosticity Ratio

We can calculate diagnosticity ratio for a set of identification parades using either `diag_ratio_W` for Wells & Lindsay's (1980) diagnosticity ratio formula, or `diag_ratio_T` for Tredoux's (1998) adjusted diagnosticity ratio. 

* Both functions require the same set of arguments: a vector of lineup choices in which the target was present (TP), a vector of lineup choices in which the target was absent (TA), as well as target positions and nominal size for TP and TA lineups, respectively. These last arguments are declared by the user. 

```{r, indent = "  "}
#Target present & target absent lineup data for 1 lineup pair 
TP_lineup <- CGTmock$lineup_1
TA_lineup <- CGTmock$lineup_3

#Compute diagnosticity ratio
diag_ratio_W(TP_lineup, TA_lineup, pos_pres = 3, pos_abs = 7, k1 =8, k2 = 8)
diag_ratio_T(TP_lineup, TA_lineup, pos_pres = 3, pos_abs = 7, k1 =8, k2 = 8)

```
* We can also calculate the variance of the diagnosticity ratio:
```{r, indent = "  "}
var_diag_ratio(TP_lineup, TA_lineup, 3, 7, 8, 8)
```
_Note:_ `var_diag_ratio` relies on Wells & Lindsay's original formula for computing diagnosticity ratio.

### Differences between Independent Diagnosticity Ratios

The functions included in this package are based on Colin G. Tredoux's approach to calculating homogeneity for k independent diagnosticity ratios, as detailed in Tredoux (1998).

#### Calculate homogeneity for _k_ independent diagnosticity ratios, using normal theory estimates

```{r}

```

#### Calculate homogeneity for _k_ independent diagnosticity ratios, with bootstrapped confidence intervals
